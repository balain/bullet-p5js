<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=400, initial-scale=1.0">
  <title>P5.js Bullet Chart</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.min.js"></script>
</head>
<body>
<script>
  /* Create bullet chart in a single run - no looping
   * Based on Stephen Few's spec: http://www.perceptualedge.com/articles/misc/Bullet_Graph_Design_Spec.pdf
   */
  function setup() {
    let params = getURLParams()

    const label = params.label || ''
    const max = params.max || 100
    const val = params.val || 50
    const bins = params.bins || 4
    const width = params.width || 400
    const height = params.height || 30

    let b = new Bullet(decodeURIComponent(label), val, max, bins, width, height)
    if (params.cross) {
      b.addCross(params.cross)
    }

    let c = createCanvas(b.getWidth(), b.getHeight())
    b.display()
    noLoop()
    // saveCanvas(c, 'bullet', 'png') // Uncomment to download PNG output every time
  }

/**
 * Class to create Bullet chart
 */
class Bullet {
  /**
   * Constructor
   * @param {string} label - Text label
   * @param {integer} value - Value
   * @param {integer} max - Maximum
   * @param {integer} binCount - Number of bins (2-5)
   * @param {integer} width - Width of the canvas
   * @param {integer} height - Height of the canvas
   * 
   * Elements (per the spec)
   * - Text Label
   * - Quantitative Scale
   * - Featured Measure
   * - One or two comparative measures (optional)
   * - From two to five ranges along the quantitative scale
   */
  constructor(label, value, max = 100, binCount, width = 200, height = 30) {
    this.buffer = 5  // Horizontal buffer
    this.vbuffer = 3  // Vertical buffer (above/below chart)
    this.barHeight = this.buffer

    this.label = label ? label : ''
    this.value = value
    this.max = max
    this.maxFactor = max/100
    this.canvasWidth = width
    this.canvasHeight = height

    this.binCount = binCount

    this.cx = false

    this.textWidth = textWidth(this.label)
    // Calculate the bounding box of the chart (without text label)
    if (this.textWidth > 0) {
      this.chartX = this.textWidth + (2 * this.buffer)
    } else {
      this.chartX = 0
    }

    this.chartY = 0
    this.chartWidth = this.canvasWidth - this.chartX - this.buffer
    this.chartHeight = this.canvasHeight - (4 * this.vbuffer)

    this.ppp = this.chartWidth / this.max // points per pixel
  }

  display() {
    // Label
    if (textWidth(this.label) > 0) {  // Only print if there's something to print
      textSize(11)
      textAlign(LEFT, TOP)
      text(this.label, this.buffer, this.vbuffer)
    }
    
    // Boxes
    noStroke()
    textSize(9)
    // Create the shaded backgrounds
    for (let i = 0; i < this.binCount; i++) {
      (i === 0) ? textAlign(LEFT, CENTER) : textAlign(CENTER, CENTER)
      let shade = ((100 * (i + 1)) / (this.binCount + 1))
      if (shade < 10) { shade *= 10 }
      // console.log('shade: ', shade)
      fill(0, shade)
      rect(this.chartX, 0, this.chartWidth - (i * this.chartWidth/this.binCount), this.chartHeight)
      fill(0, 255)
      text(Math.round(this.max*i/this.binCount), this.chartX + (i * this.chartWidth/this.binCount), (this.chartHeight + (2 * this.vbuffer)))
    }
    textAlign(RIGHT, CENTER)
    text(this.max, this.chartX + this.chartWidth, (this.chartHeight + (2 * this.vbuffer)))
    
    // Main Value Bar
    fill(0)
    let bw = this.ppp * this.value
    let bh = this.barHeight
    let bx = this.chartX
    let by = this.chartHeight/2 - bh/2
    rect(bx, by, bw, bh)

    // Cross
    if (this.cx) {
      rect(this.cx, this.cy, this.cw, this.ch)
    }
  }

  move() { /* no-op */ }

  addCross(x) {
    this.cx = this.chartX + (this.ppp * x)
    this.cy = this.vbuffer
    this.cw = this.barHeight
    this.ch = this.chartHeight - (2 * this.vbuffer)
  }

  getWidth() { return(this.canvasWidth) }
  getHeight() { return(this.canvasHeight) }

}
</script>
</body>
</html>